# -*- coding: utf-8 -*-
"""Capstone Project3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13gjVJ1lxbwio32XedHFzj-lsB1cO_iLT

# Imports the relevant libraries
 Initializes the regions country codes and checks API access status.
"""

import pandas as pd
from pandas import json_normalize
import json
import os
import requests
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
import pickle
from google.colab import files
import itertools
import shutil
from google.colab import files
import ast
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import zipfile
import glob


# Define the regions (country codes)
regions = ["global", "US", "TR", "RU", "BR", "FR", "JM"]

# Your bearer token
access_key = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiIsImtpZCI6IjI4YTMxOGY3LTAwMDAtYTFlYi03ZmExLTJjNzQzM2M2Y2NhNSJ9.eyJpc3MiOiJzdXBlcmNlbGwiLCJhdWQiOiJzdXBlcmNlbGw6Z2FtZWFwaSIsImp0aSI6ImViOTMwZWIxLTlhMTMtNGQyYi04ODI1LTYwNmVhNTlmNDgxMyIsImlhdCI6MTczNDQwNzA4OSwic3ViIjoiZGV2ZWxvcGVyLzY2ZTE2NTlmLTAxN2ItMDBkYS04MmRhLWY2MmY0NjVkNzAzZSIsInNjb3BlcyI6WyJicmF3bHN0YXJzIl0sImxpbWl0cyI6W3sidGllciI6ImRldmVsb3Blci9zaWx2ZXIiLCJ0eXBlIjoidGhyb3R0bGluZyJ9LHsiY2lkcnMiOlsiMzQuOTEuOTAuOTgiXSwidHlwZSI6ImNsaWVudCJ9XX0.YH5fJX_BBjeBZvQv6doRKw2LZajeWzKcPx-nsHXv5hxIOFxXz7uCz5xg31YZjc8wQ5oPSvl5sUr0ZtVTLWgjHQ"
# Define the headers with the bearer token
headers = {
    "Authorization": f"Bearer {access_key}",
    "Content-Type": "application/json"  # Adjust content type if necessary
}

def check_apiAccess():
  # Make the API call
  # Define the the default API endpoint
  url = "https://api.brawlstars.com/v1/rankings/global/players"
  response = requests.get(url, headers=headers)

  # Check the response status code
  if response.status_code != 200:

      print(f"Error: {response.status_code}")
      print("Please generate new API Key.")
      print(response.text)  # Print error details if available

  else:
      print("API Access Status:", response.status_code)

  return

check_apiAccess()

"""# Retrieves rankings data for each region (regions)

"""

def get_rankings_by_country(access_key):
    """
    Fetches Brawl Stars player rankings for specified countries.

    Args:
        access_key: Your Brawl Stars API bearer token.

    Returns:
        A dictionary where keys are country codes and values are DataFrames.
    """

    # Define the base API endpoint
    base_url = "https://api.brawlstars.com/v1/rankings"


    # Initialize an empty dictionary to store the DataFrames
    all_rankings = {}

    # Iterate through the regions and fetch data
    reg = regions
    for region in reg:
        # Construct the API URL for the current region
        url = f"{base_url}/{region}/players"

        # Define the headers
        headers = {
            "Authorization": f"Bearer {access_key}",
            "Content-Type": "application/json"
        }

        # Make the API request
        response = requests.get(url, headers=headers)

        # Check for successful response
        if response.status_code == 200:
            # Process the data and create a DataFrame
            data = response.json()
            df = json_normalize(data, record_path=['items'])

            # cleans df by removing the name, nameColor, and icon.id columns:
            df.drop(['name', 'nameColor', 'icon.id'], axis=1, inplace=True)

            # Add the country code as a column (for easy identification)
            df['country_code'] = region


            # Store the DataFrame in the dictionary
            all_rankings[region] = df
        else:
            print(f"Error fetching data for {region}: {response.status_code}")

    # Return the dictionary of DataFrames
    return all_rankings

def save_rankings_separately(rankings_data_dict, regions):
    """
    Saves player rankings from a dictionary of DataFrames into separate CSV files.

    Args:
        rankings_data_dict: A dictionary where keys are regions and values are DataFrames.
        regions: A list of regions to save.
    """
    output_dir_base = "rankings"
    os.makedirs(output_dir_base, exist_ok=True)  # Create the base directory

    for region in regions:
        df = rankings_data_dict.get(region)  # Use get to handle missing regions
        if df is not None:
            file_path = os.path.join(output_dir_base, f"{region}.csv")
            df.to_csv(file_path, index=False)  # Save the entire DataFrame
            print(f"Rankings for {region} saved in '{file_path}'")
        else:
            print(f"Rankings data for region '{region}' not found.")

if not os.path.exists('sampled_rankings_dictionary.pkl'):
  if not os.path.exists('rankings'):
      rankings_data = get_rankings_by_country(access_key)
      save_rankings_separately(rankings_data, regions)
      for region, df in rankings_data.items():
        print(f"DataFrame for {region}:")
        display(rankings_data[region].head())
        rankings_data[region].info()

if not os.path.exists('sampled_rankings_dictionary.pkl'):
  reg = regions
  for region in reg:
      globals()[f'{region.lower()}_rankings'] = rankings_data[region]
  br_rankings.info()
  display(br_rankings.head())
  print("-" * 30)
  fr_rankings.info()
  display(fr_rankings.head())
  print("-" * 30)
  jm_rankings.info()
  display(jm_rankings.head())
  print("-" * 30)
  ru_rankings.info()
  display(ru_rankings.head())
  print("-" * 30)
  tr_rankings.info()
  display(tr_rankings.head())
  print("-" * 30)
  us_rankings.info()
  display(us_rankings.head())
  print("-" * 30)
  global_rankings.info()
  display(global_rankings.head())
  print("-" * 30)

if not os.path.exists('sampled_rankings_dictionary.pkl'):
  if os.path.exists('/content/rankings'):
    if not os.path.exists('/content/rankings_files.zip'):
      shutil.make_archive('rankings_files', 'zip', '/content/rankings')
      files.download('rankings_files.zip')

def handle_missing_values(df, exclude_cols=['club.name']):
    """
    Handles missing values in a DataFrame, excluding specified columns, and displays missing value counts.

    Args:
        df: The DataFrame to process.
        strategy: The strategy to use for filling missing values ('mode', 'mean', 'median', or 'drop').
                  Defaults to 'mode'.
        exclude_cols: A list of column names to exclude from the 'drop' strategy.

    Returns:
        The DataFrame with missing values handled.
    """
    print("Missing Values Before Handling:")
    print(df.isnull().sum())  # Display missing values before

    return

def clean_brawl_stars_data(df, exclude_cols=['club.name']):
    """
    Cleans a Brawl Stars player rankings DataFrame.

    Args:
        df: The DataFrame to clean.

    Returns:
        The cleaned DataFrame.
    """

    # Data Type Conversion: Converts 'trophies', 'rank', and 'expLevel' to numeric
    for col in ['trophies', 'rank']:
        df[col] = pd.to_numeric(df[col], errors='ignore')

    # 3. Removing Duplicates
    df.drop_duplicates(inplace=True)


    return df

if not os.path.exists('sampled_rankings_dictionary.pkl'):
  missing = regions
  print(regions)
  for missing, df in rankings_data.items():
      print(f"Handling missing values for {missing}:")
      cleaned_df = clean_brawl_stars_data(df)
      df = cleaned_df
      print("Missing Values Before Handling:")
      print(df.isnull().sum())  # Display missing values before


      # Print max and min trophies
      max_trophies = cleaned_df['trophies'].max()
      min_trophies = cleaned_df['trophies'].min()
      print(f"  Max Trophies: {max_trophies}")
      print(f"  Min Trophies: {min_trophies}")

      print("-" * 30)

"""# Rankings Sampling
Takes a random sample of 100 players of the top 200 from each region.
"""

if os.path.exists('/content/sampled_rankings_dictionary.pkl'):
    print("sampled_rankings_dictionary.pkl already exists")
    with open('/content/sampled_rankings_dictionary.pkl', 'rb') as f:
        sampled_rankings_dictionary = pickle.load(f)

if not os.path.exists('/content/sampled_rankings_dictionary.pkl'):
  us_rank_sample = us_rankings.sample(n=100)
  tr_rank_sample = tr_rankings.sample(n=100)
  ru_rank_sample = ru_rankings.sample(n=100)
  br_rank_sample = br_rankings.sample(n=100)
  fr_rank_sample = fr_rankings.sample(n=100)
  jm_rank_sample = jm_rankings.sample(n=100)
  global_rank_sample = global_rankings.sample(n=100)
  sampled_rankings_dictionary = {
      "US": us_rank_sample,
      "TR": tr_rank_sample,
      "RU": ru_rank_sample,
      "BR": br_rank_sample,
      "FR": fr_rank_sample,
      "JM": jm_rank_sample,
      "global": global_rank_sample  # Add global_rank_sample
  }

"""dictionary of dataframes


"""

if not os.path.exists('sampled_rankings_dictionary.pkl'):
  # Save the dictionary to a pickle file
  with open('sampled_rankings_dictionary.pkl', 'wb') as f:
      pickle.dump(sampled_rankings_dictionary, f)

  # Download the pickle file
  files.download('sampled_rankings_dictionary.pkl')

sampled_rankings_dictionary['US']

"""# Retrieves Battle Logs Helper functions
Gets the past 25 battle logs for the top 200 players in each region (regions) from API
"""

def get_brawler_name_by_tag(teamcompostions, search_tag):
    """
    Extracts the brawler name of a specific player using their player tag.

    Args:
        cell_content: The content of the DataFrame cell containing the player data.
        search_tag: The player tag to search for.

    Returns:
        The brawler name of the player, or None if the player tag is not found.
    """
    k = search_tag
    for team in teamcompostions:
        for player in team:
            if player['tag'] == k:
                return player['brawler']['name']
    return None  # Player tag not found

def sort_list_column(df, column_name):
    """
    Sorts lists in a specified column of a pandas DataFrame alphabetically.

    Args:
        df: The pandas DataFrame.
        column_name: The name of the column containing the lists.

    Returns:
        A new DataFrame with the specified column's lists sorted alphabetically.
    """

    df[column_name] = df[column_name].apply(lambda x: sorted(x) if isinstance(x, list) else x)
    return df

print(regions)

def clean_battle_log(df):
  """
  Removes the .....

  Args:
    df: The input DataFrame.

  Returns:
    The cleaned DataFrame.
  """

  #Select and reorder columns
  df = df.sort_values(by='p1', ascending= True)
  df = df[df['home'].apply(lambda x: isinstance(x, list) and len(x) == 3)]
  df = df[df['home'].apply(lambda x: isinstance(x, list) and len(x) == 3)]
  df = sort_list_column(df, 'home')
  selected_columns = ['event.map', 'battle.mode',	'battle.result', 'p1', 'home', 'starplayer.stat']
  df= df[selected_columns]



  return df

def get_brawler_name_by_tag(data_list, target_tag):
  """
  Searches for the brawler name of a player with a specific tag.

  Args:
      data_list (list): A list of lists representing teams, where each inner list
                        contains dictionaries with player information, including
                        'tag' and 'brawler'. The 'brawler' key is expected to
                        have a 'name' key containing the brawler's name.
      target_tag (str): The player tag to search for within the team data.

  Returns:
      str or None: The name of the brawler used by the player with the
                    'target_tag', if found. Returns None if the 'target_tag'
                    is not found in the 'data_list'.
  """
  for team in data_list:
      for player in team:
          if player['tag'] == target_tag:
              return player['brawler']['name']
  return None  # Tag not found


def get_teammate_brawler_names(data_list, target_tag):
    """
    Retrieves the brawler names of players on the same team as someone
    with a specific tag.

    Args:
        data_list (list): A list of lists representing teams, where each
                          inner list contains dictionaries with player
                          information, including 'tag' and 'brawler'. The
                          'brawler' key is expected to have a 'name' key
                          containing the brawler's name.
        target_tag (str): The player tag to search for within the team data.

    Returns:
        list or None: A list of brawler names of the teammates (including the
                      player with the 'target_tag'), or None if the
                      'target_tag' is not found in any team.
    """
    if isinstance(data_list, float) and np.isnan(data_list):
      return None
    else:
      for team in data_list:
          for player in team:
              if player['tag'] == target_tag:  # Found the target player
                  # Extract brawler names of all players on this team
                  return [p['brawler']['name'] for p in team]


def get_away_brawler_names(data_list, target_tag):
    """
    Retrieves the brawler names of players on the opposing team
    (away team) from someone with a specific tag.

    Args:
        data_list (list): A list of lists representing teams, where each
                          inner list contains dictionaries with player
                          information, including 'tag' and 'brawler'. The
                          'brawler' key is expected to have a 'name' key
                          containing the brawler's name.
        target_tag (str): The player tag to search for to identify the
                          opposing team.

    Returns:
        list or None: A list of brawler names of the players on the opposing
                      team, or None if the 'target_tag' is not found in any
                      team or if there is only one team in 'data_list'.
    """
    if isinstance(data_list, float) and np.isnan(data_list):
      return None
    else:
      for team in data_list:
            for player in team:
                if player['tag'] != target_tag:  # Found the target player
                    # Extract brawler names of all players on this team
                    return [p['brawler']['name'] for p in team]
      # Target tag not found in any team

def star_player_on_team(data_list, target_tag, star):
    c1 = False
    c2 = False
    # Add 'starplayer.stat' column
    for team in data_list:

      for player in team:
          print(f"Type of player: {type(player)}")
          print(f"Player: {player}")

          if isinstance(player, dict) and 'tag' in player and player['tag'] == target_tag:
              c1 = True
          elif isinstance(player, list) and player[0] == target_tag:  # Adjust if tag is not the first element
              c1 = True
          return c1
          if isinstance(player, dict) and 'tag' in player and player['tag'] == target_tag:
              c2 = True
          elif isinstance(player, list) and player[0] == target_tag:  # Adjust if tag is not the first element
              c2 = True
          return c2
          if c1 and c2:
            return 1
          else:
            return 0
    return

def augment_battle_data(df, search_tag):
    import  ast
    """
    Augments a battle DataFrame with player-specific information.

    Args:
        df: The input DataFrame containing battle data.


    Returns:
        A new DataFrame with added columns: 'p1', 'home', 'away'.
    """




    # Create new columns using the helper functions
    new_df = df.copy()


    for index, row in new_df.iterrows():
      value = row['battle.teams']
      value = ast.literal_eval(value)
      p1 = get_brawler_name_by_tag(value, search_tag)  # Apply your function
      new_df.loc[index, 'p1'] = p1
      def get_home_brawlers(row, search_tag):
        teams = ast.literal_eval(row['battle.teams'])
        return get_teammate_brawler_names(teams, search_tag)

      def get_away_brawlers(row, search_tag):
        teams = ast.literal_eval(row['battle.teams'])
        return get_away_brawler_names(teams, search_tag)

      new_df['home'] = new_df.apply(lambda row: get_home_brawlers(row, search_tag), axis=1)
      new_df['away'] = new_df.apply(lambda row: get_away_brawlers(row, search_tag), axis=1)



    # Add 'starplayer.stat' column
    new_df['starplayer.stat'] = new_df.apply(lambda row: 1 if row['battle.starPlayer.tag'] == search_tag else 0, axis=1)



    return new_df

def get_battle_logs(ptag):
    """
    Fetches Brawl Stars player battle logs for specified players.

    Args:
        ptag (list or pd.Series): A list or Series of player tags.

    Returns:
        (dict): A dictionary where keys are player tags and values are
              DataFrames containing battle logs. Empty DataFrame if
              an error occurs during fetching.
    """

    base_url = "https://api.brawlstars.com/v1/players"
    headers = {
        "Authorization": f"Bearer {access_key}",
        "Content-Type": "application/json"
    }

    battle_logs = {}

    for tag in ptag:
        # Format player tag to remove '#' and replace with '%23'. Brawl Stars API: The Brawl Stars API likely expects player tags to be URL-encoded, so replacing '#' with '%23' ensures that the tag is properly formatted for the API request.
        formatted_tag = tag.replace("#", "%23")
        url = f"{base_url}/{formatted_tag}/battlelog"

        response = requests.get(url, headers=headers)

        if response.status_code == 200:

            data = response.json()
            #data = json_normalize(data, record_path=['items'])
           # aug = augment_battle_data(data, ptag)
            battle_logs[tag] = json_normalize(data, record_path=['items'])
        else:
            print(f"Error fetching battle logs for {tag}: {response.status_code}")

    return battle_logs

"""# Save Battle Log From API Helper functions"""

def save_battle_logs_separately(battle_logs_dict,region):
    """
    Saves player battle logs from a dictionary of DataFrames into separate files.

    Args:
        battle_logs_dict: A dictionary where keys are player tags and values are DataFrames.
        player_tags_col: The name of the column containing player tags in the DataFrames.
        output_dir: The directory where the CSV files will be saved (default: "battle_logs").
    """
    output_dir_base = "battle_logs"

    output_dir = os.path.join(output_dir_base, region)

    os.makedirs(output_dir, exist_ok=True)  # Create output directory if it doesn't exist

    for tag, dic_df in battle_logs_dict.items():
        # Add the player tag as a column
        dic_df = battle_logs_dict[tag]

        # Construct file path for saving
        file_path = os.path.join(output_dir, f"{tag.replace('#', '')}.csv")  # Remove '#' from tag for filename

        # Save DataFrame to CSV file
        dic_df.to_csv(file_path, index=False)

    print(f"Battle logs for {region} saved in '{output_dir}' directory.")

reg = regions
print(reg)

def save_region_battle_logs(rankings_data_dic):
    """
    Saves player battle logs for a specific region into separate files.

    Args:
        rankings_data: The dictionary containing rankings DataFrames for different regions.
        region: The region (country code) to fetch battle logs for.
"""
    output_dir_base="battle_logs"
    #Get player tags for the specified region

    for region in regions:
      player_tags = rankings_data_dic[region]['tag']
      region_battle_logs_dict = get_battle_logs(player_tags)
       # Save battle logs separately for each player in the region
      save_battle_logs_separately(region_battle_logs_dict, region)  # Changed to 'player_tag'

def read_csv_to_dict(directory_path):
       """Reads all CSV files in a directory into a dictionary of DataFrames.

       Args:
           directory_path: The path to the directory containing the CSV files.

       Returns:
           A dictionary where keys are file names (without extension)
           and values are the corresponding DataFrames.
       """
       csv_files = glob.glob(os.path.join(directory_path, "*.csv"))  # Get all CSV files
       dfs = {}  # Initialize an empty dictionary
       for file in csv_files:
           file_name = os.path.splitext(os.path.basename(file))[0]  # Get file name without extension
           dfs[file_name] = pd.read_csv(file)  # Read CSV into DataFrame
       return dfs

"""# Load Battle Logs"""

if not 'battle_logs' in globals():
    battle_logs = {}
    for region in regions:
      pickle_file = f"/content/{region}_battle_logs.pkl"
      if os.path.exists(pickle_file):
        print(pickle_file, " already exists and loaded.")
            # Create an empty dictionary for battle logs
        with open(pickle_file, 'rb') as f:
            battle_logs [region]= pickle.load(f)  # Store the battle log in the dictionary
      else:
          save_region_battle_logs(rankings_data)  # Save battle logs if pickle doesn't exist
          print(f"Battle Logs top 200 players for {region}: saved")
else:
  print("battle_logs already exists in globals")

display(battle_logs['US']['20GLVPVR'])

print(regions)

for region in regions:
       directory_path = f"{region}_battle_logs.pkl"  # Path to region's directory
       if not os.path.exists(directory_path):
        dfs_dict = read_csv_to_dict(directory_path)  # Assuming read_csv_to_dict is defined

        # Save the dictionary to a pickle file
        pickle_file_path = f"{region}_battle_logs.pkl"
        with open(pickle_file_path, 'wb') as f:
            pickle.dump(dfs_dict, f)

        # Download the pickle file
        files.download(pickle_file_path)

if os.path.exists('/content/battle_logs'):
  sihutil.make_archive(zip_battle_logs, 'zip', '/content/battle_logs')
  files.download(zip_battle_logs + '.zip')

#Tests augment_battle_data function
n = augment_battle_data(battle_logs['US']['20GLVPVR'], '#20GLVPVR')
display(n)

display(battle_logs['US']['20GLVPVR'])

#rankings_data['FR']

def get_battle_log_for_tag(region, search_tag):
    """
    Gets the battle log for a specific player tag from a specific region.

    Args:
        battle_logs_base_dir: The base directory where battle logs are stored.
        region: The region (country code).
        player_tag: The player tag.

    Returns:
        A pandas DataFrame containing the battle log, or None if not found.
    """
    battle_logs_base_dir = "battle_logs"

    # Construct the file path for the battle log
    file_name = f"{search_tag.replace('#', '')}.csv"  # Remove '#' from tag for file name
    file_path = os.path.join(battle_logs_base_dir, region, file_name)

    # Check if the file exists
    if os.path.exists(file_path):
        # Read the battle log into a DataFrame
        battle_log_df = pd.read_csv(file_path)
        battle_log_df = augment_battle_data(battle_log_df, search_tag)

        # Return the DataFrame
        return battle_log_df
    else:
        print(f"Battle log for player '{search_tag}' in region '{region}' not found.")
        return None

def save_battle_logs_to_pickle(battle_logs, region):
    """
    Saves battle logs for a specific region to a pickle file.

    Args:
        battle_logs (dict): A dictionary where keys are regions
                            and values are battle log data.
        region (str): The region for which to save the battle logs.
    """
    file_path = os.path.join('battle_logs', f"{region}.pkl")  # Construct file path
    with open(file_path, 'wb') as f:
        pickle.dump(battle_logs.get(region), f)  # Use get to handle missing regions
    files.download(file_path)
    print(f"Battle logs for {region} saved to '{file_path} and downloaded'")

sampled_rankings_dictionary['FR']

battle_logs['BR']['LV9YPVUCQ']

combin_sample_battle_logs = {}  # Dictionary to store DataFrames
r = ["US", "TR", "RU", "BR", "FR"]
for region in r:
    combin_sample_battle_logs[region] = []  # Initialize list for each region
    sample_tags = sampled_rankings_dictionary[region]['tag']
    for tag in sample_tags:
        try:  # Handle potential KeyError
            df = battle_logs[region][tag.replace('#', '')]
            df = df.dropna(subset=['battle.teams'])
            df = augment_battle_data(df, tag)
            df['player_tag'] = tag  # Add
            combin_sample_battle_logs[region].append(df)
        except KeyError:
            print(f"Battle log for tag '{tag}' not found in region '{region}'")
            # Handle the KeyError (e.g., skip, log the error, etc.)

combined_df = pd.DataFrame()  # Create an empty DataFrame

for dfs in combin_sample_battle_logs.values():  # Iterate over the values (lists of DataFrames)
    for df in dfs:  # Iterate over DataFrames in the list

        combined_df = pd.concat([combined_df, df], ignore_index=True)

display(combined_df.head())
combined_df.info()

filtered_df = clean_battle_log(combined_df)
filtered_df.reset_index(drop=True, inplace=True)
display(filtered_df.head())
filtered_df.info()

filtered_df[filtered_df['home'].apply(lambda x: x == ['AMBER', 'STU', 'TARA'])]

if not os.path.exists('filtered_battle_logs.csv'):
  filtered_df.to_csv('filtered_battle_logs.csv', index=False)
  files.download('filtered_battle_logs.csv')

def get_unique_lists(df, column_name):
  """
  Extracts unique lists from a specified column of a DataFrame.

  Args:
    df: The input DataFrame.
    column_name: The name of the column containing lists.

  Returns:
    A NumPy array of unique lists.
  """

  # Convert lists to tuples to make them hashable for unique()
  unique_tuples = pd.unique(df[column_name].apply(tuple))

  # Convert tuples back to lists
  unique_lists = [list(tup) for tup in unique_tuples]

  return unique_lists

characters = sorted(filtered_df['p1'].unique())
num_characters = len(characters)
print(f"Number of unique values in 'p1': {num_characters}")
print(characters)

import itertools

# Define group size and permutation size
group_size = 87
per_size = 3

# Generate permutations
permutations = itertools.permutations(range(group_size), per_size)

# Get the number of permutations
num_permutations = len(list(permutations))

# Print the result
print(f"The number of permutations of {group_size} from a group of {per_size} is: {num_permutations}")

unique_combos = get_unique_lists(filtered_df, 'home')
num_combos = len(unique_combos)
print(f"Number of unique found in battle logs combos: {num_combos}")
print(unique_combos)

def group_by_p1_character(df):
  """
  Groups a DataFrame by unique characters in the 'p1' column,
  creating a new DataFrame for each character and storing them in a dictionary.

  Args:
    df: The input DataFrame.

  Returns:
    A dictionary where keys are unique characters from the 'p1' column
    and values are the corresponding filtered DataFrames.
  """


  character_dfs = {}  # Dictionary to store DataFrames

  for char in characters:
    # Filter for rows where 'p1' matches the current character
    fil_df= df[df['p1'] == char]
    fil_df = fil_df.sort_values(by=['home'], ascending=True)
    fil_df.reset_index(drop=True, inplace=True)
    character_dfs[char] = fil_df  # Add filtered DataFrame to dictionary

  return character_dfs

if not os.path.exists('character_df.pkl'):
  character_df = group_by_p1_character(filtered_df)
  # Save the dictionary to a pickle file
  with open('character_df.pkl', 'wb') as f:
    pickle.dump(character_df, f)

  # Download the pickle file
  files.download('character_df.pkl')
else:
  with open('character_df.pkl', 'rb') as f:
    character_df = pickle.load(f)

character_df['BUZZ']

def calculate_win_rate(df):
  """
  Calculates the win rate from a DataFrame using the 'battle.result' column.

  Args:
    df: The input DataFrame containing battle results.

  Returns:
    The win rate as a float (between 0 and 1).
  """

  #'victory' indicates a win
  wins = df[df['battle.result'] == 'victory'].shape[0]
  total_battles = df.shape[0]

  # Handle case of 0 battles to avoid ZeroDivisionError
  win_rate = wins / total_battles if total_battles else 0

  return win_rate

def calculate_star_player_rate(df):
  """
  Calculates the star player rate from a DataFrame using the 'starplayer.stat' column.

  Args:
    df: The input DataFrame containing star player information.

  Returns:
    The star player rate as a float (between 0 and 1).
  """

  #1 in 'starplayer.stat' indicates being a star player
  star_player_count = df[df['starplayer.stat'] == 1].shape[0]
  total_battles = df.shape[0]

  star_player_rate = star_player_count / total_battles if total_battles else 0  # Handle case of 0 battles

  return star_player_rate

"""# New Section

# Overall Synergy
"""

# Read the CSV file into a DataFrame
brawler_stats_df = pd.read_csv('/content/brawler_base_stats.csv')
#replace nan values with 0
brawler_stats_df = brawler_stats_df.fillna(0)
brawler_stats_df['form/pet'] = brawler_stats_df['form/pet'].astype(bool)
brawler_stats_df['hyper'] = brawler_stats_df['hyper'].astype(bool)
brawler_stats_df['name'] = brawler_stats_df['name'].str.upper()
#sort by class and name
brawler_stats_df = brawler_stats_df.sort_values(by=['class', 'name'])
#add win_rate column to brawler_stats_df by calculating win_rate in each character_df
for char, df in character_df.items():
  win_rate = calculate_win_rate(df)
  brawler_stats_df.loc[brawler_stats_df['name'] == char, 'win_rate'] = win_rate

brawler_stats_df.reset_index(drop=True, inplace=True)



# Display the first few rows of the DataFrame (optional)
display(brawler_stats_df)

# Calculate synergy scores for triplet combinations
def calculate_synergy_triplets(df, my_lists):
    synergy_scores = {}
    brawler_combos = iter(my_lists)
    for combo in brawler_combos:
        # Filter rows where all 3 brawlers in the combo are not null
        subset = df[df['home'].apply(lambda x: x == list(combo))]
        win_rate = calculate_win_rate(subset)
        # Convert the list 'combo' to a tuple to make it hashable
        synergy_scores[tuple(combo)] = win_rate
    return synergy_scores

# Calculate synergy scores
synergy_scores_triplets = calculate_synergy_triplets(filtered_df, unique_combos)

# Normalize synergy scores
max_score = max(synergy_scores_triplets.values())
synergy_scores_triplets = {k: v / max_score for k, v in synergy_scores_triplets.items()}

display(synergy_scores_triplets)

columns_list = list(brawler_stats_df.columns)
print(columns_list)

import pandas as pd
from sklearn.preprocessing import MinMaxScaler

# Create a MinMaxScaler object
scaler = MinMaxScaler()

# Get a list of columns to normalize, excluding specified columns
cols_to_normalize = brawler_stats_df.select_dtypes(include=np.number).columns.difference(
    ['name', 'class', 'form/pet']
)

# Normalize the selected columns
brawler_stats_df[cols_to_normalize] = scaler.fit_transform(brawler_stats_df[cols_to_normalize])

display(brawler_stats_df.head())

# Convert columns to numeric before performing calculations
for col in ['speed', 'attack_dmg', 'atk_range', 'reload_spd', 'super_dmg',
            'super_range', 'pet_health', 'pet_dmg', 'pet_range',
            'healing_move', 'shield']:
    brawler_stats_df[col] = pd.to_numeric(brawler_stats_df[col], errors='coerce')

brawler_stats_df['performance_score'] = (
    brawler_stats_df['speed'] * 0.10 +         # Weight for speed
    brawler_stats_df['attack_dmg'] * 0.20 +        # Weight for attack damage
    brawler_stats_df['atk_range'] * 0.10 +     # Weight for attack range
    brawler_stats_df['reload_spd'] * 0.05 +    # Weight for reload speed
    brawler_stats_df['super_dmg'] * 0.15 +     # Weight for super damage
    brawler_stats_df['super_range'] * 0.05 +   # Weight for super range
    brawler_stats_df['pet_health'] * 0.05 +    # Weight for pet health
    brawler_stats_df['pet_dmg'] * 0.05 +       # Weight for pet damage
    brawler_stats_df['pet_range'] * 0.02 +     # Weight for pet range
    brawler_stats_df['healing_move'] * 0.05 +  # Weight for healing move
    brawler_stats_df['shield'] * 0.03          # Weight for shield
)

# Adjust scores for hypercharge and win rate
def adjust_score_with_win_rate(row, hypercharge_weight=1.1, win_rate_weight=0.2):
    """
    Adjust performance score based on hypercharge and win rate.

    Parameters:
    - row: A row of the brawler_stats DataFrame.
    - hypercharge_weight: Multiplier for brawlers with hypercharge.
    - win_rate_weight: Weight to scale the influence of win rate.
    """
    # Base performance score
    score = row['performance_score']

    # Adjust for hypercharge
    if row['hyper']:
        score *= hypercharge_weight

    # Adjust for win rate
    if 'win_rate' in row:  # Ensure 'win_rate' column exists
        score *= (1 + row['win_rate'] * win_rate_weight)

    return score

# Apply adjustment to all brawlers
brawler_stats_df['adjusted_score'] = brawler_stats_df.apply(adjust_score_with_win_rate, axis=1)
brawler_performance = brawler_stats_df[['name', 'class', 'adjusted_score']]
scaler = MinMaxScaler()
brawler_performance['normalized_adjusted_score'] = scaler.fit_transform(brawler_performance[['adjusted_score']])

display(brawler_performance)

#drop adjusted_score and rename normalized_adjusted_score to score
if 'adjusted_score' in brawler_performance.columns:
  brawler_performance = brawler_performance.drop(columns=['adjusted_score'])
  brawler_performance = brawler_performance.rename(columns={'normalized_adjusted_score': 'score'})

brawler_performance.loc[brawler_performance['name'] == 'BUZZ LIGHTYEAR']

"""# Graphs

"""

# Sort by adjusted_score in descending order
brawler_performance = brawler_performance.sort_values(by=['score'], ascending=False)

# Get top 5 brawlers in each class
top_brawlers = brawler_performance.groupby('class').head(5)

# Create the chart
figsize = (12, 1.2 * len(top_brawlers['class'].unique()))
plt.figure(figsize=figsize)
sns.barplot(data=top_brawlers, x='score', y='name', hue='class', orient='h', palette= 'husl')
plt.title('Top 5 Brawlers by Score, Grouped by Class')
plt.xlabel('Score')
plt.ylabel('Brawler Name')
plt.gca().spines[['top', 'right']].set_visible(False) # Remove top and right spines
plt.tight_layout()
plt.show()

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(brawler_performance['class'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(brawler_performance, x='score', y='class', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

from matplotlib import pyplot as plt
import seaborn as sns
brawler_stats_df.groupby('class').size().plot(kind='barh', color=sns.palettes.mpl_palette('Dark2'))
plt.gca().spines[['top', 'right',]].set_visible(False)
plt.xlabel('Number of brawlers')

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(brawler_stats_df['class'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(brawler_stats_df, x='atk_range', y='class', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(brawler_stats_df['class'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(brawler_stats_df, x='reload_spd', y='class', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(brawler_stats_df['class'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(brawler_stats_df, x='super_dmg', y='class', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)

from matplotlib import pyplot as plt
import seaborn as sns
figsize = (12, 1.2 * len(brawler_stats_df['class'].unique()))
plt.figure(figsize=figsize)
sns.violinplot(brawler_stats_df, x= 'performance_score', y='class', inner='stick', palette='Dark2')
sns.despine(top=True, right=True, bottom=True, left=True)



"""# Merge Synergy Scores and Stats for Analysis"""

synergy_scores_triplets_df = pd.DataFrame.from_dict(synergy_scores_triplets, orient='index', columns=['synergy_score'])
synergy_scores_triplets_df.reset_index(inplace=True)
synergy_scores_triplets_df.rename(columns={'index': 'trio'}, inplace=True)
display(synergy_scores_triplets_df)

from sklearn.preprocessing import MinMaxScaler

def add_synergy_score(synergy_scores_triplets_df, brawler_performance):
    """
    Adds synergy score and individual brawler scores to a new column.

    Args:
        synergy_scores_triplets_df: DataFrame with synergy scores and brawler trios.
        brawler_performance: DataFrame with brawler performance scores.

    Returns:
        A copy of synergy_scores_triplets_df with a new 'total_synergy' column.
    """
    df_copy = synergy_scores_triplets_df.copy()  # Create a copy
    df_copy['total_synergy'] = 0  # Initialize the new column

    for index, row in df_copy.iterrows():
        brawlers = row['trio']  # Get the list of brawlers for this row
        total_score = row['synergy_score']  # Start with the synergy score

        for brawler in brawlers:
            # Get the adjusted_score for the current brawler
            brawler_score = brawler_performance.loc[brawler_performance['name'] == brawler, 'score'].values[0]
            total_score += brawler_score  # Add to the total score

        df_copy.loc[index, 'total_synergy'] = total_score  # Update the total_synergy column

    # Normalize total_synergy using MinMaxScaler
    scaler = MinMaxScaler()
    df_copy['total_synergy'] = scaler.fit_transform(df_copy[['total_synergy']])

    return df_copy

brawler_synergy_df = add_synergy_score(synergy_scores_triplets_df, brawler_performance)
#sort dataframe by trio
brawler_synergy_df = brawler_synergy_df.sort_values(by=['trio'], ascending=True)
#normalize values in total_synergy column
brawler_synergy_df

display(brawler_synergy_df)

top_10_trios = brawler_synergy_df.nlargest(10, 'total_synergy')

# Convert 'trio' column to strings for plotting
top_10_trios['trio'] = top_10_trios['trio'].astype(str)  # Convert tuples to strings

plt.figure(figsize=(10, 6))
sns.barplot(x='total_synergy', y='trio', data=top_10_trios, palette='viridis')  # Use 'viridis' color palette
plt.title('Top 10 Combinations by Total Synergy Score')
plt.xlabel('Total Synergy Score')
plt.ylabel('Team Combinations')



"""# Brawl Ball"""

stats_df = brawler_stats_df.drop(columns=['win_rate'])
display(stats_df)

# def sort_by_brawl_ball(char_df):
#   """
#   Sorts the DataFrames in character_df by 'battle.mode' for Brawl Ball.

#   Args:
#     character_df: The dictionary containing character DataFrames.

#   Returns:
#     The updated character_df with sorted DataFrames.
#   """

#   for char, df in char_df.items():
#       # Filter for Brawl Ball mode
#       brawl_ball_df = df[df['battle.mode'] == 'brawlBall']

#       # Sort by 'home' column
#       brawl_ball_df = brawl_ball_df.sort_values(by=['home'], ascending=True)

#       # Update the character_df with the sorted Brawl Ball DataFrame
#       dataframedf = brawl_ball_df



#   return dataframedf

#function to sort a dictionary using the battle.mode column entered
def sort_by_brawl_ball(char_df):
  """
  Sorts the DataFrames in character_df by 'battle.mode' for Brawl Ball.

  Args:
    character_df: The dictionary containing character DataFrames.

  Returns:
    The updated character_df with sorted DataFrames.
  """
  ball_character_df = {}
  for char, df in char_df.items():
      # Filter for Brawl Ball mode
      brawl_ball_df = df[df['battle.mode'] == 'brawlBall']
      ball_character_df[char] = brawl_ball_df
  return ball_character_df

ball_character_dic = sort_by_brawl_ball(character_df)
#character_df['BUZZ']
display(ball_character_dic['BUZZ'])

#add win_rate column to ball_stats_df by calculating win_rate in each character_df
ball_stats_df = stats_df.copy()
for char, df in ball_character_dic.items():
  win_rate = calculate_win_rate(df)
  ball_stats_df.loc[ball_stats_df['name'] == char, 'win_rate'] = win_rate

ball_stats_df.reset_index(drop=True, inplace=True)



# Display the first few rows of the DataFrame (optional)
display(ball_stats_df)

ball_filtered_df = filtered_df[filtered_df['battle.mode'] == 'brawlBall']
ball_unique_combos = get_unique_lists(ball_filtered_df, 'home')
ball_num_combos = len(ball_unique_combos)
print(f"Number of unique found in battle logs combos: {ball_num_combos}")
print(ball_unique_combos)

ball_filtered_df

# Calculate synergy scores
ball_synergy_scores_triplets = calculate_synergy_triplets(ball_filtered_df, ball_unique_combos)

# Normalize synergy scores
max_score = max(ball_synergy_scores_triplets.values())
ball_synergy_scores_triplets = {k: v / max_score for k, v in synergy_scores_triplets.items()}

display(ball_synergy_scores_triplets)

#compare the difference between the values for each group between ball_synergy_scores_triplets and synergy_scores_triplets
difference = {k: ball_synergy_scores_triplets[k] - synergy_scores_triplets[k] for k in ball_synergy_scores_triplets}
display (difference)